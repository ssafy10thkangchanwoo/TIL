
def partition(A, l, r):
    # 피봇 정하기 (제일 왼쪽 부분)
    p = A[l]

    # 피봇보다 작은거는 왼쪽부터 놓고, 큰거는 오른쪽부터 놓고
    i, j = l, r  
    # i : 왼쪽에 있으면 안되는 원소의 위치를 찾는 인덱스, 피봇보다 큰 원소의 위치 왼쪽부터 찾기
    # l : 오른쪽에 있으면 안되는 원소의 위치를 찾는 인덱스, 피봇보다 작은 원소의 위치 오른쪽부터 찾기
    
    # if A[l] 

    while i <= j:
        # 피봇보다 큰 거를 왼쪽부터 찾기 시작
        while i <=j and A[i] <= p:
            # i번째 위치에 있는 원소가 피봇보다 작으면 오른쪽으로 한칸 가서 찾기 계속
            i += 1            
        # 피봇보다 작은거를 오른쪽에서 찾기 시작
        while i<=j and A[j] >= p:
            # 현재 j번째 위치에 있는 원소가 피봇보다 크면 왼쪽으로 한칸 가서 찾기를 계속
            j -= 1
        
        # i 가 j보다 작으면 위치가 잘못된 두 원소를 찾음.
        if i < j:
            # 잘못된 원소끼리 자리 교환
            A[i], A[j] = A[j], A[i] 

    # 반복이 끝나면 작은 것과 큰 것이 다 제자리에 있다.
    # 피봇의 위치를 정해준다.
    A[l], A[j] = A[j], A[l]
    
    # 정렬이 끝난 피봇의 위치를 return
    return j 
        

# A 정렬할 대상 리스트
# l : 왼쪽 인덱스
# r : 오른쪽 인덱스


# new*
def QuickSort(A, l, r):
    if l < r:
    # 분할하고 피봇의 위치를 구한다.
        s = partition(A, l, r)
    # s의 위치는 정해지고 s의 나머지 부분에 대해서 분할정렬 이어가기
    # s를 제외한 왼쪽부분
        QuickSort(A, l, s-1)
        # s를 제외한 오른쪽 부분
        QuickSort(A, s+1, r)


list = [11, 45, 23, 81, 28, 34]
N = len(list)
QuickSort(list, 0, N-1)
print(list)